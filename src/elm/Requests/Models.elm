module Requests.Models exposing (Request(..), NewRequestData
                                , RequestStore, RequestStoreData
                                , RequestPayload, RequestPayloadArgs(..)
                                , Response(..)
                                , ResponseDecoder, noopDecoder
                                , initialRequest, createRequestData, encodeRequest

                                -- Custom requests
                                , ResponseForUsernameExists(..), ResponseUsernameExistsPayload
                                , ResponseForSignUp(..), ResponseSignUpPayload
                                , ResponseForLogin(..), ResponseLoginPayload)


import Dict
import Json.Encode

import App.Components exposing (Component(ComponentInvalid))

-- Requests

type Request
    = RequestUsername
    | RequestEmailVerification
    | RequestSignUp
    | RequestLogin
    | RequestInvalid
    | NewRequest NewRequestData

{- RequestStore is a dict with information about all requests we are waiting for
responses. This dict is identified by the request id (an UUID generated by the
client, sent as `request_id` on payload and received as `request_id` once the
server replies us). It is stored on the main App Model. -}
type alias RequestStoreData = (Component, Request, ResponseDecoder)
type alias RequestStore = Dict.Dict String RequestStoreData

{- NewRequestData is a 3-tuple used internally when creating new requests. It
contains all required information to queue and submit a new request to the
server. This type alias is used to simplify the representation of the 3-tuple.
-}
type alias NewRequestData = (Request, RequestPayload, ResponseDecoder)

{- RequestPayload represents the payload we send to the server. It is identical
for every request, except for the `args` key. The `args` is unique for each
Request. -}
type alias RequestPayload =
    { topic : String
    , args : RequestPayloadArgs
    , request_id : String
    }

{- RequestPayloadArgs is a list of Request payloads along with their expected
args. The actual definition of expected payload args is implemented below for
each request-}
type RequestPayloadArgs
    = RequestUsernamePayload RequestUsernameArgs
    | RequestEmailVerificationPayload RequestEmailVerificationArgs
    | RequestSignUpPayload RequestSignUpArgs
    | RequestLoginPayload RequestLoginArgs

{- Expected payload for each Request's args -}

type alias RequestUsernameArgs =
    { user : String}

type alias RequestEmailVerificationArgs =
    { email : String}

type alias RequestSignUpArgs =
    { email : String, password : String, username : String }

type alias RequestLoginArgs =
    { username: String, password: String }

-- Responses

type Response
    = ResponseUsernameExists ResponseForUsernameExists
    | ResponseSignUp ResponseForSignUp
    | ResponseLogin ResponseForLogin
    | ResponseEmpty
    | ResponseInvalid

{- ResponseDecoder is used internally and it's an alias to represent the result
of decoders implemented on each component's requests module. Regardless of the
input (which is the key `data` received on a WSResponse) we must always return
a Response, which then will be handled by the component. -}
type alias ResponseDecoder = String -> Int ->  Response

{- Expected content on the `data` field of the response received by the server.
It is analogous to `RequestPayloadArgs`-}
-- type ResponseData
--     = ResponseDataUsernameExists ResponseForUsernameExists
--     | ResponseDataSignUp ResponseForSignUp
--     | EmptyResponse

type ResponseCode = Number

{- Definition of each Response's expected fields and/or state -}

type ResponseForUsernameExists
    = ResponseUsernameExistsOk ResponseUsernameExistsPayload
    | ResponseUsernameExistsInvalid

type alias ResponseUsernameExistsPayload =
    { user : String }

type ResponseForSignUp
    = ResponseSignUpOk ResponseSignUpPayload
    | ResponseSignUpInvalid

type alias ResponseSignUpPayload =
    { user : String }


type ResponseForLogin
    = ResponseLoginOk ResponseLoginPayload
    | ResponseLoginFailed
    | ResponseLoginInvalid

type alias ResponseLoginPayload =
    { token : String }

{-| encodeRequest will encode the payload to a jsonified string. -}
encodeRequest : RequestPayload -> String
encodeRequest payload =
    Json.Encode.encode 0
      (Json.Encode.object
          [ ("topic", Json.Encode.string payload.topic)
          , ("args", encodeArgs payload.args)
          , ("request_id", Json.Encode.string payload.request_id)
          ])


{-| encodeArgs is the specific encoding part of the parent encodeRequest. Since
the content of `args` varies for each request, we must tell Elm how to encode
each RequestPayloadArgs. -}
encodeArgs : RequestPayloadArgs -> Json.Encode.Value
encodeArgs args =
    case args of

        RequestUsernamePayload args ->
            Json.Encode.object
                [ ("user", Json.Encode.string args.user) ]

        RequestEmailVerificationPayload args ->
            Json.Encode.object
                [ ("email", Json.Encode.string args.email )]

        RequestSignUpPayload args ->
            Json.Encode.object
                [ ("email", Json.Encode.string args.email)
                , ("username", Json.Encode.string args.username)
                , ("password", Json.Encode.string args.password)]

        RequestLoginPayload args ->
            Json.Encode.object
                [ ("username", Json.Encode.string args.username)
                , ("password", Json.Encode.string args.password)]

{-| Aggregates the required data to create a request into a 3-tuple defined by RequestData -}
createRequestData : Request -> ResponseDecoder -> String -> RequestPayloadArgs -> NewRequestData
createRequestData request decoder topic args =
        (request
        , { topic = topic
          , args = args
          , request_id = ""
          }
        , decoder)

-- Initial data

noopDecoder : ResponseDecoder
noopDecoder msg code =
    ResponseInvalid


initialRequest : RequestStore
initialRequest =
    Dict.fromList [("", (ComponentInvalid, RequestInvalid, noopDecoder))]

